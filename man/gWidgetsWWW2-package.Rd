% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/gcomponent.R, R/gwidget.R, R/gwidgets-package.R
\docType{data}
\name{GComponent}
\alias{GComponent}
\alias{GWidget}
\alias{gWidgetsWWW2-package}
\title{Base class for all Ext objects}
\format{\preformatted{Class 'R6ClassGenerator' <environment: 0x1df9780> 
 - attr(*, "name")= chr "GComponent_generator"
}}
\usage{
GComponent

GWidget
}
\description{
The \code{GComponent} class provides the base class for all widgets.

\code{GWidget} is the base class for widget objects. See
\code{GContainer} for the base class for container objects. Both
derive from the \code{GComponent} class.

This package uses the \pkg{Rook} package of Jeffrey Horner to
allow R programmers to easily create interactive web pages from
within an R session.
}
\details{
The basic setup of gWidgetsWWW2 involves a set of constructors and
S3 methods for manipulating the constructed objects. The
constructors return R6 class objects. The S3 methods then
simply pass arguments along to the appropriate R6 class
method. Of course, these may be called directly, but for
portability of gWidgets code to other toolkits this is not
recommended. However, for methods that are only implemented in a
given toolkit, such method calls become necessary and
desirable. In documenting the R6 class objects just those
exposed methods which must be called as methods are
mentioned.

The GComponent class is used to define methods common to  all the
widgets. This class also includes methods for processing
callbacks. This is different in gWidgetsWWW2. The basic idea is
that JavaScript is used to make a callback into the session
containing (using the session id to find the correct evaluation
environment). Passed along are an object id (to find the signaling
object), a signal (to look up the handlers assigned to that object
for the given signal) and possibly some extra parameters. The
latter are there to bypass the transport calls that are used to
synchronize the widget state from the browser with the R session
data. These transport calls are asynchronous so may not have been
processed when the handler call is processed.

The lookup used above requires each widget to be registered in a
toplevel object which is unique to a page. This toplevel object is
found from the session id, which then looks up the object from the
passed in object id. This toplevel object is passed into a widget
via either the \code{container} argument or the \code{parent}
argument. In addition to routing requests to handlers, the
toplevel object also is used to send back JavaScript commands to
the browser. The method \code{add_js_queue} is all that is needed
for this. A convenience method \code{call_Ext} provides an
alternative. For this method one specifies a method name and named
arguments that are converted to a JavaScript object to
parameterize the method call. Somewhat reverse to this is calling
an R object from JavaScript. The method \code{call_rpc} is used
for this, where in the JavaScript code one uses \code{jRpc} to
initiate the call and \code{add_public_method} to register that an
object's method is available to be called in this manner.

Methods related to the handler code are \code{add_handler},
\code{invoke_handler}, \code{handler_widget},
\code{connect_to_toolkit},  \code{transport_fun},
\code{process_transport}, \code{param_defn},
\code{before_handler}

The original reference class interface of gWidgetsWWW2 was meant to be
implemented by all gWidgets implementations.
So gWidgets2WWW -- if that ever happens -- would use
the basic reference class interface, but for now gWidgetsWWW2 has been
ported to use R6 classes to improve speed.

Installation:

There is a choice of web server. For serving local pages, the Rook package can use R's httpd server.

For serving pages to a wider world one can

* open R's httpd server's port to the wider world (not recommended)

Just call the load_app command on a script and the page will render.

* proxy this through something, like nginx

We follow the steps in J Horner's gist (https://gist.github.com/6d09536d871c1a648a84)

1) install nginx: sudo apt-get install nginx
2) configure nginx by adding this to /etc/nginx/sites-enabled/default (in the servef bit)

location /custom {
proxy_pass http://localhost:19000/custom;
}

* run scripts under rapache

For nginx
}
\author{
John Verzani \email{jverzani@gmail.com}
}
\keyword{datasets}
\keyword{package}

